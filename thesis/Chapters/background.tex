% !TeX spellcheck = en_US
% Chapter Template

\chapter{Background and related work} % Main chapter title

\label{chap:background} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

\lhead{Chapter \ref*{chap:background}. \emph{Background and related work}} % Change X to a consecutive number; this is for the header on each page - perhaps a shortened title



\section{Baseline architecture}
The current system design consists of multiple levels. It is a multi-process application based on the programming languages C++ and Rust. The source code is mainly aligned to be built on Microsoft Windows. A port to Unix based systems is currently in work. Therefore parts of the code base are aligned for multiple system architectures already, but the application is not yet able to be compiled for Linux.

Each microservice of the application is included dynamically and linked as a \ac{DLL} file. For starting the microservice environment, a central executable ("open\_\ twin.exe") is started with the corresponding arguments for the services (like binding address, port numbers, encrypted passwords) and the path to the \ac{DLL} file itself. The UI frontend, which is started by the user directly, is compiled in its own executable ("uiFrontend.exe").
For conveniently running the services with all their necessary arguments, batch files were provided that read environment variables and convert them into runtime arguments for the service executable.
The system consists of the following microservices that are permanently accessible: \ac{GSS}, \ac{AUTH} and the database. The database is running on MongoDB\footnote{MongoDB:~https://www.mongodb.com/}. Another Service is the \ac{LSS} that spawns the so called application services. Those are services for logging, scripting, 3D modeling, kriging and so on.
While \ac{GSS}, \ac{AUTH} and database are globally accessible, the \ac{LSS} can theoretically run on a dedicated host and is only communicated to other parties after it has registered itself to the \ac{GSS}.

Once started, the user can login. In order to connect to the database, the following steps are performed:
\begin{enumerate}
\item The \ac{UI} frontend requests further service information from the \ac{GSS}. It responses with \acp{URL} to the database and the \ac{AUTH}.
\item The \ac{UI} frontend connects to the \ac{AUTH} using the authentication information provided by the user.
\item If the \ac{AUTH} replies with a positive authentication, the \ac{UI} frontend connects to the database and lists the projects.
\item Once a project is opened or created, the \ac{UI} frontend requests a new session from the \ac{GSS}. The \ac{GSS} replies with the connection \acp{URL} from the \ac{LSS}. The \ac{LSS} has been registered to the \ac{GSS} during its initialization.
\item The \ac{UI} frontend then connects to the \ac{LSS} and requests a new session. As a result, the \ac{LSS} spawns new application service processes and replies with the respective service \acp{URL}.
\item From now on, the \ac{UI} frontend communicates with the application services.
\end{enumerate}

The traffic between services is encrypted using \ac{mTLS} technology. While regular \ac{TLS} ensures the authenticity of the server by using Certificates and the chain of trust, it does not verify the identity of the client. This is the benefit of \ac{mTLS}. In \ac{mTLS}, both sides, client and server has to verify their identity by providing a certificate inherited from a common root certificate.

\section{Problem statement}
Even though, the application is clearly based on a microservice architecture, it is not able to run on a distributed system yet. It consists of multiple processes that have to run on the same system and need a full working operating system as baseline. Containerization of the system has never been tested (!!erprobt!!) and needs to be introduced. 
% Automatic service extension = Automatische erweiterung der Services auf neuen Nodes
Additionally, the automatic service extension requires communication between the cluster orchestration management and the applications running on the nodes.

Regarding logging, while the frontend application does, the microservices currently do not produce log files. Instead, all sub processes write the information on its standard output stream.


\section{Related Work}
